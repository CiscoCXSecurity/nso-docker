* NSO in Docker for development and production
  This repository contains all you need to build Docker images out of Cisco NSO. It produces two Docker images;
  - a production image
    - stripped of documentation and similar to make it small
    - use this as a base image in the Dockerfile for your production container image
      - add your own packages on top
  - a development image
    - contains Java compiler and other useful tools
    - can be used directly to compile packages and similar

  The development image can be used immediately, for example as the image for a CI docker container runner to use for running CI jobs that involve compilation of NSO packages and similar. The production image is intended to be used as a base image on which you add your own packages, like NEDs and your service packages, to produce a final image for your environment.

* How and why?
  There are many reasons for why Docker and containers in general might be good for you. The main drivers for using Docker with NSO lies around packaging, ensuring consistency in testing and production as well as making it simple and convenient to create test environments.

  - build a docker image out of a specific version of NSO and your packages
    - distributed as one unit!
    - you test the combination of NSO version X and version Y of your packages
      - think of it as a "version set"
    - the same version set that is tested in CI is deployed in production
      - guarantees you tested same thing you deploy
    - conversely, using other distribution methods, you increase the risk of testing one thing and ending up deploying something else - i.e. you didn't really test what you use in production
  - having NSO in a container makes it easy to start
    - simple to test
    - simple to run in CI
    - simple to use for development
  - you do NOT need Kubernetes, Docker swarm or other fancy orchestration
    - run Docker engine on a single machine

  It's also worth noting that using Docker does not mean you have to replace all of your current infrastructure. If you are currently using OpenStack or some system that primarily deals with virtual machines you don't have to rip this out. On the particular VM that runs NSO you can simply install Docker and have a single machine Docker environment that runs NSO. You are using Docker for the packaging features!


* Usage
  The ideal scenario would be to ship prebuilt Docker images containing NSO but as legal requirements prevent that, this is the second best option. This repository contains recipes that you can use to produce Docker images yourself. Just add +water+ Cisco NSO ;)

** Building
*** Manually building Docker images on your local machine
   - Clone this repository to your local machine
     - ~git clone git@github.com/NSO-Developer/cisco-nso.git~
   - Download Cisco NSO
     - go to https://developer.cisco.com/docs/nso/ and click the "Download NSO for evaluation (Linux)" in the side bar
   - Place downloaded .bin file in ~nso-install-files/~
   - run ~make~ in repository root directory
     - *NOTE*: running docker commands, which are invoked by ~make~, typically require root privileges or membership in the ~docker~ group
   - verify your new images are built with ~docker images~ which should look something like:

   #+BEGIN_SRC shell
     kll@ThinkLite:~/cisco-nso# docker images
     REPOSITORY          TAG                 IMAGE ID            CREATED             SIZE
     cisco-nso           5.2                 c451b581d328        19 hours ago        435MB
     cisco-nso           4.7.5               3096fe46bee9        19 hours ago        433MB
     cisco-nso-dev       5.2                 a986314ec390        22 hours ago        435MB
     <none>              <none>              7e680e680923        22 hours ago        410MB
     cisco-nso-dev       4.7.5               0565a58c3977        22 hours ago        433MB
     <none>              <none>              d968a53420ab        22 hours ago        421MB
     bitnami/minideb     buster              25dfa3b9a987        23 hours ago        67.5MB
     docker              stable              b40e5afd78f5        2 weeks ago         216MB
     kll@ThinkLite:~/cisco-nso#
   #+END_SRC
*** Automatically building Docker images using Gitlab CI
   - Clone this repository to your local machine
     - ~git clone git@github.com/NSO-Developer/cisco-nso.git~
   - Download Cisco NSO
     - go to https://developer.cisco.com/docs/nso/ and click the "Download NSO for evaluation (Linux)" in the side bar
   - Place downloaded .bin file in ~nso-install-files/~
   - commit file(s) in ~nso-install-files/~ using git LFS and push
     - ~git add nso-install-files/*~
     - ~git commit nso-install-files -m "Add NSO install files"~
       - it is a good practice to add the files one by one and write the version you added in the commit message, like "Add NSO install file for v4.7.5"
     - ~git push -u origin master~
     - CI will now build the docker images for you
       - naturally provided you first setup CI
   - verify your new images are built by going to the container repository in Gitlab viewing the list of container images

*** Alternative for providing NSO install files into CI runner
    The above method involves committing the NSO install files to this git repository (your clone of it). This means the repository must be private so that you don't leak the NSO install files nor the produced Docker images. There are a number of reasons for why this setup might not be ideal;
    - you have an open source public and wish to run CI publicly
    - LFS doesn't work with your choice of code hosting
    - NSO install files are too big or you just don't like LFS

    There is an alternative. The path in which the build process looks for the NSO install file(s) is specified by ~NSO_INSTALL_FILES_DIR~. The default value is ~nso-install-files/~, i.e. a directory relative to the root of the repository. The standard way of delivering the NSO install files, as outlined in the process above, is to place the NSO files in that directory. The alternative is to change the ~NSO_INSTALL_FILES_DIR~ variable. Note how you can set this environment variable through the GitLab CI settings page under variables. You do *not* need to commit anything. In case you are running Gitlab CI with the ~docker~ runner, add the path to the list of ~volumes~, for example:

    #+BEGIN_SRC text
      [[runners]]
        name = "my-runner"
        url = "https://gitlab.com/"
        token = "s3cr3t"
        executor = "docker"
        [runners.docker]
          tls_verify = false
          image = "debian:buster"
          privileged = false
          disable_entrypoint_overwrite = false
          oom_kill_disable = false
          disable_cache = false
          volumes = ["/cache", "/var/run/docker.sock:/var/run/docker.sock", "/data/vrnetlab-images:/images"]
          shm_size = 0
    #+END_SRC

    The path ~/data/vrnetlab-images~ on the host machine becomes available as ~/images/~ in the CI build docker containers and by specifying that path (~/images~) using the CI variable settings, the job will now pick up the NSO images from there. This is how the public repo at https://gitlab.com/plajjan/cisco-nso works. It allows us to host all code in public, run CI tests in public yet not reveal the NSO install file as required by its EULA.
** Running
*** Run standalone for testing
    - if you built a production image, i.e. using base image from this repo and adding in your own packages
    - run a standalone container
    - no persistent volume - since we are doing testing we don't need to survive a restart
    - use docker networking - connect to other things running in docker, like netsim etc

    #+BEGIN_SRC shell
      docker run -itd --name nso-dev1 my-prod-image:12345
    #+END_SRC

*** Run for development
    - mount the source code directory into the container
    - makes it possible to use compiler etc in the container
    - avoid installing compilers and other tools directly on your computer

    #+BEGIN_SRC shell
      docker run -itd --name nso-dev1 -v $(pwd):/src cisco-nso-dev:5.2
    #+END_SRC

*** Run for production
    - with a production image, i.e. using the base image from this repo and adding in your own packages
    - use shared volume to persist data across restarts
      - CDB (NSO database)
      - SSH & SSL keys
      - NETCONF notification replay
      - rollbacks
      - backups
      - optionally NSO logs
        - if remote (syslog) logging is used there is little need to persist logs
        - if local logging, then persisting logs is a good idea
    - possibly use --net=host to share IP address with host machine
      - makes it easier to handle connectivity

    This uses the ~--net=host~ option to let the container live in the hosts networking namespace. This means that it binds to the IP address of the (virtual) machine it is running on. Also note that we use a shared volume for logs. ~/log~ inside the container contains the logs and you can access them outside the container in ~/data/nso-logs~.
    #+BEGIN_SRC shell
      docker run -itd --name nso -v /data/nso:/nso -v /data/nso-logs:/log --net=host my-prod-image:12345
    #+END_SRC

** Configuration options
   The ncs.conf configuration file for NSO is written at run time of the container. It is generated (modified to be precise) at startup of the container. It is possible to influence the configuration through a number of variables. These can be fed into the container through environment variables.

   | Environment variable | Type    | Default | Description                                   |
   |----------------------+---------+---------+-----------------------------------------------|
   | PAM                  | boolean | false   | Enable PAM instead of local auth in NSO (AAA) |
   | HTTP_ENABLE          | boolean | false   | Enable HTTP web UI                            |
   | HTTPS_ENABLE         | boolean | false   | Enable HTTPS (TLS) web UI                     |

*** HTTPS TLS certificate
    When no certificate is present, one will be generated. It is a self-signed certificate valid for 30 days making it possible to use both in development and staging environments. It is not meant for production. You *should* replace it with a proper signed certificate for production and it is encouraged to do so even for test and staging environments.

* Docker image tags
It is recommended that the Docker images are tagged with an identifier that is unique per build.

* Admin user
  An admin user can be created on startup by the run script in the container. There are three environment variables that control the addition of an admin user;
  - ~ADMIN_USERNAME~: username of the admin user to add, default is ~admin~
  - ~ADMIN_PASSWORD~: password of the admin user to add
  - ~ADMIN_SSHKEY~: private SSH key of the admin user to add

  As ~ADMIN_USERNAME~ already has a default value, only ~ADMIN_PASSWORD~ or ~ADMIN_SSHKEY~ need to be set in order to create an admin user. For example:
  #+BEGIN_SRC shell
    docker run -itd --name nso -e ADMIN_PASSWORD=foobar my-prod-image:12345
  #+END_SRC

  This can be very useful when starting up a container in CI for testing or when doing development. It is typically not required in a production environment where there is a permanent CDB that already contains the required user accounts.

  Also note how this only adds a user. If you are using a permanent volume for CDB etc and start the NSO container multiple times with different ~ADMIN_PASSWORD~ then the last run will effectively overwrite the older password. However, if you change ~ADMIN_USERNAME~ between invocations then you will create multiple users! An admin user account created during the last run of NSO will *not* be removed just because ~ADMIN_USERNAME~ is set to a different value.

* Python VM version
  These docker images default to using python3.

  In NSO v5.3 and later, the python VM to use is probed by first looking for ~python3~, if not found ~python2~ will be tried and finally it will fall back to running ~python~. In earlier versions of NSO, ~python~ is executed, which on most systems means python2. As python2 is soon end of life, these docker images default to using ~python3~.

* Backup
  *NOTE*: SSH keys and SSL certificates are not included in backups produced by ~ncs-backup~.
  Backup and restore largely behaves as it normally does with ~ncs-backup~ as run outside of Docker, with some exceptions.

  Normally, the ncs-backup script includes the NCS_CONFIG_DIR (defaults to /etc/ncs). SSH keys and SSL certificates are normally placed in /etc/ncs/ssh and /etc/ncs/ssl respectively. This means that the SSH keys and SSL certificates are part of the produced backup file. This is NOT the case for when NSO is run in a container as SSH keys and SSL certificates are not in the default configuration path.

** Taking a backup
   To take a backup, simply run ~ncs-backup~. The backup file will be written to ~/nso/run/backups~.

** Restoring from a backup
   To restore a backup, NSO must not be running. As you likely only have access to the ~ncs-backup~ tool and the volume containing CDB and other run time state from inside of the NSO container, this poses a slight challenge. Additionally, shutting down NSO will terminate the NSO container.

   What you need to do is shut down the NSO container and start a new one with the same persistent shared volume mounted but with a different command. Instead of running the ~/run-ncs.sh~ which is the normal command of the NSO container, you should run something that keeps the container alive but doesn't start NSO, for example ~read DUMMY~ (it's a bash builtin command so still have to run bash). A full docker command could look like:

   #+BEGIN_SRC shell
     docker run -itd --name nso -v /data/nso:/nso -v /data/nso-logs:/log --net=host my-prod-image:12345 bash -lc 'read DUMMY'
   #+END_SRC

   You now have the NSO container running but without NSO itself. Get a shell in the container with

   #+BEGIN_SRC shell
     docker exec -it nso bash -l
   #+END_SRC

   Then run the ncs-backup restore command, for example:

   #+BEGIN_SRC shell
     ncs-backup restore /nso/run/backups/ncs-4.7.5@2019-10-07T14:41:02.backup.gz
   #+END_SRC

   Or if you want to automate the whole process slightly you could do it all using docker exec and non-interactively:

   #+BEGIN_SRC shell
     docker exec -it nso bash -lc 'ncs-backup restore /nso/run/backups/ncs-4.7.5@2019-10-07T14:41:02.backup.gz --non-interactively'
   #+END_SRC

   Restoring a NSO backup should move the current run directory (~/nso/run~ to ~/nso/run.old~) and restore the run directory from the backup to the main run directory (~/nso/run~). After this is done, shut down your temporary container and start the normal NSO container again as usual.

* GitLab CI runner
  *NOTE*: Using a Gitlab CI runner as described in this section has different security implications than what is normally associated with using containers for CI. See the Security sub-heading.

  In order to build the CI pipeline as defined for this repository you need GitLab and a GitLab CI runner. It is possible to use the free and public gitlab.com in order to host the code but you have to provide your own Gitlab CI runner. While you have access to CI runners simply by using gitlab.com to host your code, their capabilities don't match what is needed in order to build this project. Fortunately, Gitlab as a product makes it very simple to connect your own CI runner to any Gitlab instance, including the public gitlab.com one.

  1. Get a VM or a physical machine to run your CI runner.
  2. Install Debian on said machine.
  3. Follow the guide on https://docs.gitlab.com/runner/install/linux-repository.html to install the Gitlab CI runner on your machine
  4. Follow the guide at https://docs.gitlab.com/runner/register/ on how to register your runner with Gitlab
  5. Expose the docker control socket in the gitlab runner configuration

  Here's a configuration file for gitlab ci runner. Note the ~volumes~ setting which includes ~/var/run/docker.sock~ - this exposes the Docker control socket to the containers run by the CI runner which enables the containers to start /sibling/ containers.
  #+BEGIN_SRC text
    [[runners]]
      name = "my-runner"
      url = "https://gitlab.com/"
      token = "s3cr3t"
      executor = "docker"
      [runners.docker]
        tls_verify = false
        image = "debian:buster"
        privileged = false
        disable_entrypoint_overwrite = false
        oom_kill_disable = false
        disable_cache = false
        volumes = ["/cache", "/var/run/docker.sock:/var/run/docker.sock"]
        shm_size = 0
  #+END_SRC
  You naturally need to use your token and not literally ~s3cr3t~. The token is written when you do the runner registration per the guide referenced above.

** Security
   Note that exposing the Docker control socket has security implications. Containers as run by the CI runner normally provide isolation such that CI jobs are contained within the container and are unable to access anything outside of the container. By exposing the docker control socket, the CI jobs can start new containers, including starting a privileged one, which means it has root access on the host machine and enables escaping the container entirely. Do not grant access to your project or CI runner to anyone you do not trust. For example, someone that is able to create a branch on your repository can write a Gitlab CI configuration file that instructs the CI runner to run a privileged container and then gain access to the CI runner machine itself.

* Healthcheck
  The production-base image comes with a basic Docker healthcheck. It is using ncs_cmd to get the phase that NCS is currently in. Only the result status, i.e. if ncs_cmd was able to communicate with the ~ncs~ process or not, is actually observed. This tells us whether the ~ncs~ process is responding to IPC requests.

  As far as monitoring NSO goes, this is a very basic check. Just a tad above the basic process check, i.e. that the ~ncs~ process is actually alive, which is the most basic premise of production-base image.

  More advanced and deeper looking healthchecks could be conceived, for example by observing locks and measuring the time a certain lock has been held, but it is difficult to find a completely generic set of conditions for flagging NSO as healthy or unhealthy based on that. For example, if a transaction lock has been held for 5 hours, is that healthy or not? In most situations, that would be an abnormally long transaction, but does it constitute an unhealthy state? In certain operational environments it could be normal with that long transactions (for example a batch import of some data). Marking the container as unhealthy and potentially restarting it as a consequence would only make things worse.

  We really want to measure some form of progress, even if that progress is just internal. A five hours transaction is fine as long as we are continuously making progress. However, there are currently no such indicators available and so the healthcheck observes the rather basic operation of the IPC listener.
* FAQ / Questions and answers
** Q: Why are these images not based on alpine or some other minimal container friendly image
   *A*: The larger the final container image is, the less impact the base image size typically has. Picking a 5MB or 50MB base image is not crucial when the final image is an order of magnitude larger.

   Debian was chosen as it is a well working proven distribution with a long track record. It is supported by a considerably sized community.

   minideb, which is a minimal build of a debian base image, was not only considered but actually used in early phases of this repository. It does provide a smaller image. Measured at the time of the switch from minideb to stock debian, the difference was about 10%. minideb weighed in at 471MB while debian:buster came in at 525MB. The proven track record of Debian ultimately made it the winner.
