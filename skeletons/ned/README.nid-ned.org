* NSO in Docker: NED standard form skeleton
  This is the README file for the NSO in Docker (NID) standard form NED skeleton. If you see this file (=README.nid-ned.org=) in a repository, it means the repository follows the standard form.

  The NED standard form provides a standardized environment for how to do development (=devenv=) and testing (=testenv=). It ships with a CI configuration file for GitLab that enables the test environment to automatically run in CI. All repositories using these skeletons provide a consistent user interface.

* Usage of a repo that follows the NED standard form
  Run ~make all~ to build and test the NED. You will need to set the =NSO_VERSION= environment variable and likely =NSO_IMAGE_PATH=, for example:

  #+BEGIN_SRC shell
    export NSO_VERSION=5.3
    export NSO_IMAGE_PATH=registry.gitlab.com/my-group/nso-docker/
    make all
  #+END_SRC

  The =all= make target will first build images using the =build= target and then run the test suite using the =test= target.

** NSO_VERSION
   As the version of NSO is a parameter throughout the entire NSO in Docker ecosystem, you have to supply the NSO version through the environment variable =NSO_VERSION=.

** NSO_IMAGE_PATH
   The =NSO_IMAGE_PATH= specifies the location of the NSO images that are used for building. If you have built NSO in Docker images locally, i.e. you have the images =cisco-nso-base= and =cisco-nso-dev= available locally, you do not need to set =NSO_IMAGE_PATH=. If you want to use images built elsewhere, perhaps from a CI system, you need to specify the path to the Docker registry hosting the images, like =registry.gitlab.com/my-group/nso-docker/=.

** Building and testing
   As part of the =build= make target, three docker images are produced:
   - =netsim=: a Docker image that runs the NED as a netsim device
   - =testnso=: an NSO image that has the NED loaded
     - it runs NSO on start and is thus ready to use the NED to talk to, for example, the =netsim= device
   - =ned=: a Docker image that only contains the compiled NED
     - this container can't be run, it's only a vessel to carry the compiled output to another Docker image build

   To produce these images, a multi-stage Dockerfile is used where the first stage compiles packages and later stages produce the mentioned images.

   After build, the test suite will start up a test environment (=testenv=) that consists of:
   - =netsim= container running the =netsim= image
   - =nso= container running the =testnso= image

   Then the tests, defined in the =testenv-test= target of the repository specific =Makefile=, are run. The skeleton contains an example for how to run basic tests on the NED that verifies (together with the build):
   - YANG models compiles (happens as part of =build=)
   - compiled NED loads in NSO (or the =testnso= container would fail to start)
   - netsim starts up
   - NSO can write configuration to the =netsim= and read it back
     - this test is accomplished by loading an XML configuration file that needs to be customised for the particular NED
       - do note however that it is the ONLY step that needs customization to achieve (CI) testing of a NED
       - modify the file at =test/device-config-hostname.xml=

** The test environment - testenv
   There are a number of make targets related to the control of =testenv=:
   - =testenv-start=: Start the test environment
     - the standard topology, which consists of one test NSO instance (of the =testnso= image) and one netsim (of the =netsim= image) is defined in the standard form NED skeleton
     - a Docker network specific to this testenv is used
       - this makes it possible to have network localized names, like a netsim can be called and accessed via the name =dev1= and Docker handles name resolution to the actual IP address
         - running multiple =testenv= in parallel won't collide as we have a network (namespace) per =testenv=
       - the netsim container is called =dev1=
     - it is possible to start up more containers, like netsims, which should be achieved by adding them to the =testenv-start-extra= target in =Makefile=
       - ensure that you have ~$(DOCKER_ARGS)~ in the argument list to =docker=
         - it starts the container in the correct Docker network and sets the correct label, which is a prerequisite for the =testenv-stop= target to work
   - =testenv-stop=: Stop the test environment
     - it removes all containers labeled with ~$(CNT_PREFIX)~
       - make sure any extra containers you start have this label by adding ~$(DOCKER_ARGS)~ to the argument list
     - removes the Docker network
     - removes an optional volume (see =devenv= for more info on volume usage)
   - =testenv-shell=: Get an interactive =bash= shell in the =testnso= container
   - =testenv-cli=: Get an interactive NSO CLI (=ncs_cli=) in the =testnso= container
   - =testenv-runcmd=: Run a command with =ncs_cli=, provide the command through the environment variable =CMD=
     - the =testenv-runcmd= target can be called to run a command, from an interactive shell like ~make testenv-runcmd CMD="show ncs-state version"~
     - it can also be called from other make targets, for example to run commands from tests
       - ~$(MAKE) testenv-runcmd CMD="show ncs-state version"~

   To access NSO via one of its northbound interfaces, like NETCONF or RESTCONF, use the credentials =admin= / =NsoDocker1337=.

** The development environment - devenv
   The development environment is similar to the =testenv= but additionally a =devenv= allows recompilation and reloading of packages in NSO. This enables a much shorter REPL cycle.

   Instead of starting with =testenv-start= you start up a devenv using =devenv-start=. After modifying the source you can use =devenv-build= to build your package and reload it in NSO.

   It is possible to develop using the normal build and the testenv by modifying the code and running ~make build testenv-stop test~ which will:
   - stop the currently running testenv
   - compile all packages and build new =testnso= Docker images
   - rebuild the images, stop the currently running testenv and then run the tests again (which starts the =testenv= based on the newly rebuilt images). This is slow, both because compiling large service or NED packages can take a long time (and it will be started from scratch whenever anything has changed) and because stopping and starting the Docker containers takes some time.

   When starting a =devenv=, a Docker volume is created to host the NSO packages.

** Docker tags and prefixes
   Built images are tagged with the NSO version and "PNS" ("Pipeline NameSpace", when in a CI context, or "Pseudo NameSpace", when running locally, outside of CI), like ~$(NSO_VERSION)-$(PNS)~. For local builds, PNS is set to your username (modulo some mangling as some characters are forbidden in Docker image tags), e.g. =5.3-kll= (for username =kll=). In CI, PNS is set to the CI pipeline ID, like =5.3-12345=. The PNS part means we don't immediately overwrite the previously built images with the version tag like =5.3=, which might be included by other repositories. We don't want a development version to overwrite the released one.

   Use the =tag-release= target to set the release tags on the image, e.g. go from =5.3-kll= to =5.3=. The CI configuration automatically does this for CI jobs run on the =master= branch. You might have to do it locally in case you wish to retag images so they can be tested with other repositories.

   In the =testenv= and =devenv= the started containers have a name prefix to avoid collisions with other repositories that make use of the NID skeletons. The prefix is available in the Makefiles under the ~$(CNT_PREFIX)~ variable and is set to ~testenv-$(PROJECT_NAME)-$(NSO_VERSION)-$(PNS)~. It is also possible to override by manually setting the environment variable =CNT_PREFIX=.

** Repository related make targets
   - =build=: Builds the images
   - =push=: Pushes the =ned= image
   - =tag-release=: Adds a tag with release version, like =5.3=
   - =push-release=: Pushes the release version to the Docker registry
     - this is based on the =CI_REGISTRY_IMAGE= variable set by GitLab CI

* Applying the skeleton / Creating a new repo based on the skeleton
  The NED standard form comes as a skeleton that can be applied to a repository by copying over a number of files to your repository. If you are starting from scratch, simple copy the skeleton directory (and init git), like:

  #+BEGIN_SRC shell
    cp -av ../nso-docker/skeletons/ned my-ned
    cd my-ned
    git init
    git add .
    git commit -a -m "Starting from NID skeleton for NEDs"
  #+END_SRC

  Place your NED package in the =packages/= folder, despite the plural 's' on =packages=, you should only use a single NED per repository (other skeletons in the NID ecosystem supports multiple packages). This will automatically include them in the build.

  If you are building a new NED, you can start a =devenv-shell= to run =ncs-make-package=. For this we need access to the =cisco-nso-dev= image, set =NSO_VERSION= and =NSO_IMAGE_PATH= accordingly (see top of this file for more information on that).

  #+BEGIN_SRC shell
    export NSO_VERSION=5.3
    export NSO_IMAGE_PATH=my-registry.example.com/nso-docker/
    make devenv-shell
  #+END_SRC

  Once in the =devenv-shell= we can use =ncs-make-package= to make a new package. Our package folder is mounted in =/src=. Let's say we want to make a NETCONF NED out of some YANG models in =device-yang-models/=:

  #+BEGIN_SRC shell
    cd /src/packages
    ncs-make-package --netconf-ned /src/device-yang-models myned
    chown -Rv 1000:1000 myned
  #+END_SRC

  Note how when you are working in a Docker container you are root and as such, files you create are owned by root. Change ownership to your own id/gid from within the container. Also note how the container is not aware of your username nor group, so you need to use numeric identifiers.

  Now we can build our package and start up a =testenv=:

  #+BEGIN_SRC shell
    make build
    make testenv-start
  #+END_SRC

  Modify the =Makefile= to apply the tests you want. For the NED skeleton, an example is included that tests the NED & netsim in combination, see the =Makefile= for more information.

* Skeleton content
  The NED skeleton contains the following files
  - =README.nid-ned.org=: This README file
  - =.gitlab-ci.yml=: a GitLab CI configuration file that runs the standard testenv targets
  - =nidcommon.mk=: Makefile with definitions common across the NID skeletons
  - =nidned.mk=: Makefile with common targets for the NED skeleton
  - =Makefile=: repository specific Makefile, while it comes with the skeleton, this is meant to be customized for each project
  - =run-netsim.sh=: A Docker entrypoint script for running a netsim container
  - =test/=: Directory containing test related files
  - =packages/=: Standard location for placing the NSO package for the NED itself. Despite plural, only supposed to be one NED (other skeletons in the NID ecosystem supports multiple packages)
  - =test-packages/=: Standard location for placing NSO packages for testing. These are included in the =testnso= container that can be used to test the NED but aren't included in the final output.

** Skeleton source location and updating the skeleton
   The authoritative origin for the standard form NED skeleton is the =nso-docker= repository at [[https://gitlab.com/nso-developer/nso-docker/]], specifically in the directory =skeletons/ned=. To upgrade to a later version of the skeleton, pull the files from that location and avoid touching the =Makefile= as it typically contains custom modifications. Be sure to include files starting with a dot (=.=).
